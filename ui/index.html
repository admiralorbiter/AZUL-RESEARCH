<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azul Solver & Analysis Toolkit</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .tile {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid #374151;
            user-select: none;
        }
        .tile:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .tile.dragging {
            opacity: 0.5;
            transform: scale(1.2);
            z-index: 1000;
        }
        .tile.drag-over {
            background-color: rgba(59, 130, 246, 0.3) !important;
            border-color: #3b82f6 !important;
        }
        .factory {
            border: 2px solid #374151;
            border-radius: 8px;
            padding: 8px;
            margin: 4px;
            background: #f9fafb;
        }
        .pattern-line {
            display: flex;
            gap: 2px;
            margin: 2px 0;
            min-height: 40px;
            border: 2px dashed transparent;
            border-radius: 4px;
            padding: 2px;
        }
        .pattern-line.drag-over {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }
        .wall {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin: 4px 0;
        }
        .wall-cell {
            width: 30px;
            height: 30px;
            border: 1px solid #d1d5db;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .wall-cell.drag-over {
            background-color: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }
        .heatmap-green { background-color: rgba(34, 197, 94, 0.3); }
        .heatmap-yellow { background-color: rgba(234, 179, 8, 0.3); }
        .heatmap-red { background-color: rgba(239, 68, 68, 0.3); }
        .move-option {
            padding: 8px;
            margin: 4px 0;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .move-option:hover {
            background-color: #f3f4f6;
        }
        .move-option.selected {
            background-color: #3b82f6;
            color: white;
        }
        .status-success { color: #059669; }
        .status-error { color: #dc2626; }
        .status-warning { color: #d97706; }
        
        /* Click selection visual feedback */
        .tile.selected {
            transform: scale(1.15);
            box-shadow: 0 0 0 3px #3b82f6;
            z-index: 10;
        }
        
        .pattern-line.valid-drop {
            border-color: #10b981;
            background-color: rgba(16, 185, 129, 0.1);
            border-style: solid;
        }
        
        .wall-cell.valid-drop {
            background-color: rgba(16, 185, 129, 0.3);
            border-color: #10b981;
        }
        
        .factory.valid-source {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        /* Drag and drop visual feedback */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            opacity: 0.8;
            transform: rotate(5deg);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // API Configuration - Use relative URLs to avoid CORS issues
        const API_BASE = '/api/v1';
        let sessionId = null;

        // Sandbox state management
        let moveHistory = [];
        let undoStack = [];
        let currentGameState = null;
        let draggedTile = null;
        let dragGhost = null;

        // Initialize session
        async function initializeSession() {
            try {
                const response = await fetch(`${API_BASE}/auth/session`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_agent: navigator.userAgent,
                        ip_address: '127.0.0.1'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    sessionId = data.session_id;
                    console.log('Session initialized:', sessionId);
                    return true;
                } else {
                    console.error('Session creation failed:', response.status);
                    return false;
                }
            } catch (error) {
                console.error('Failed to initialize session:', error);
                return false;
            }
        }

        // API helper functions
        async function analyzePosition(fenString) {
            if (!sessionId) {
                console.error('No session ID available');
                return null;
            }
            
            try {
                const response = await fetch(`${API_BASE}/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': sessionId
                    },
                    body: JSON.stringify({
                        fen_string: fenString,
                        depth: 3,
                        time_budget: 4.0,
                        agent_id: 0
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.analysis : null;
                } else {
                    console.error('Analysis failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Analysis error:', error);
                return null;
            }
        }

        async function getGameState(fenString = 'initial') {
            
            try {
                const response = await fetch(`${API_BASE}/game_state?fen_string=${fenString}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.game_state : null;
                } else {
                    console.error('Game state fetch failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Game state error:', error);
                return null;
            }
        }

        async function getHint(fenString) {
            if (!sessionId) {
                console.error('No session ID available');
                return null;
            }
            
            try {
                const response = await fetch(`${API_BASE}/hint`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': sessionId
                    },
                    body: JSON.stringify({
                        fen_string: fenString,
                        budget: 0.2,
                        rollouts: 100,
                        agent_id: 0
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.hint : null;
                } else {
                    console.error('Hint failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Hint error:', error);
                return null;
            }
        }

        async function analyzeNeural(fenString) {
            if (!sessionId) {
                console.error('No session ID available');
                return null;
            }
            
            try {
                const response = await fetch(`${API_BASE}/analyze_neural`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': sessionId
                    },
                    body: JSON.stringify({
                        fen_string: fenString,
                        time_budget: 1.0,
                        max_rollouts: 50,
                        agent_id: 0
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.success ? data.analysis : null;
                } else {
                    console.error('Neural analysis failed:', response.status, response.statusText);
                    return null;
                }
            } catch (error) {
                console.error('Neural analysis error:', error);
                return null;
            }
        }

        // Tile colors mapping
        const TILE_COLORS = {
            'R': '#ef4444', // red
            'B': '#3b82f6', // blue
            'Y': '#eab308', // yellow
            'W': '#f3f4f6', // white
            'K': '#1f2937', // black
        };

        // Sample game state (simplified FEN-like format)
        const SAMPLE_STATE = {
            factories: [
                ['K', 'R', 'B', 'Y', 'W', 'W'], // Factory 1: 1 black, 1 red, 1 blue, 1 yellow, 2 empty
                ['R', 'B', 'Y', 'W', 'K', 'K'], // Factory 2: 1 red, 1 blue, 1 yellow, 1 white, 2 black
                ['Y', 'B', 'W', 'K', 'R', 'W'], // Factory 3: 1 yellow, 1 blue, 1 empty, 1 black, 1 red, 1 empty
                ['Y', 'W', 'R', 'B', 'W', 'W'], // Factory 4: 1 yellow, 1 empty, 1 red, 1 blue, 2 empty
            ],
            center: ['R', 'B', 'Y'],
            players: [
                {
                    pattern_lines: [
                        ['R', 'B'],
                        ['Y'],
                        [],
                        [],
                        []
                    ],
                    wall: [
                        [false, false, false, false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false]
                    ],
                    floor: ['R', 'B']
                }
            ]
        };

        // Tile Component with proper drag-and-drop
        function Tile({ color, onClick, className = "", draggable = false, onDragStart, onDragEnd, dataAttributes = {}, isSelected = false }) {
            const tileRef = React.useRef(null);
            
            useEffect(() => {
                const tile = tileRef.current;
                if (!tile || !draggable) return;
                
                const handleDragStart = (e) => {
                    if (onDragStart) {
                        onDragStart(e, tile);
                    }
                };
                
                const handleDragEnd = (e) => {
                    if (onDragEnd) {
                        onDragEnd(e, tile);
                    }
                };
                
                tile.addEventListener('dragstart', handleDragStart);
                tile.addEventListener('dragend', handleDragEnd);
                
                return () => {
                    tile.removeEventListener('dragstart', handleDragStart);
                    tile.removeEventListener('dragend', handleDragEnd);
                };
            }, [draggable, onDragStart, onDragEnd]);
            
            return (
                <div 
                    ref={tileRef}
                    className={`tile ${className} ${isSelected ? 'selected' : ''}`}
                    style={{ backgroundColor: TILE_COLORS[color] || '#6b7280' }}
                    onClick={onClick}
                    title={color}
                    draggable={draggable}
                    {...dataAttributes}
                />
            );
        }

        // Factory Component with drag-and-drop
        function Factory({ tiles, onTileClick, heatmap = null, factoryIndex, selectedTile = null, onTileSelection = null }) {
            const factoryRef = React.useRef(null);
            
            useEffect(() => {
                const factory = factoryRef.current;
                if (!factory) return;
                
                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('drag-over');
                };
                
                const handleDragLeave = (e) => {
                    e.currentTarget.classList.remove('drag-over');
                };
                
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const tileData = e.dataTransfer.getData('application/json');
                    if (tileData) {
                        const data = JSON.parse(tileData);
                        // Handle drop on factory (not implemented yet)
                        console.log('Drop on factory:', data);
                    }
                };
                
                factory.addEventListener('dragover', handleDragOver);
                factory.addEventListener('dragleave', handleDragLeave);
                factory.addEventListener('drop', handleDrop);
                
                return () => {
                    factory.removeEventListener('dragover', handleDragOver);
                    factory.removeEventListener('dragleave', handleDragLeave);
                    factory.removeEventListener('drop', handleDrop);
                };
            }, []);
            
            return (
                <div ref={factoryRef} className="factory">
                    <div className="text-xs text-gray-600 mb-2">Factory {factoryIndex + 1}</div>
                    <div className="flex flex-wrap gap-1">
                        {tiles.map((tile, index) => {
                            const tileData = {
                                tile: tile,
                                factoryIndex: factoryIndex,
                                tileIndex: index,
                                sourceId: factoryIndex
                            };
                            const isSelected = selectedTile && 
                                selectedTile.tile === tile && 
                                selectedTile.factoryIndex === factoryIndex && 
                                selectedTile.tileIndex === index;
                            
                            return (
                                <Tile 
                                    key={index}
                                    color={tile}
                                    onClick={() => {
                                        if (onTileSelection) {
                                            onTileSelection(tileData);
                                        } else {
                                            onTileClick(tile, index);
                                        }
                                    }}
                                    className={`${heatmap ? `heatmap-${heatmap}` : ""} ${selectedTile && !isSelected ? 'valid-source' : ''}`}
                                    draggable={tile !== 'W'} // Only non-empty tiles are draggable
                                    isSelected={isSelected}
                                    onDragStart={(e, tileElement) => {
                                        console.log('Factory tile drag start:', tile, factoryIndex, index);
                                        
                                        const tileData = {
                                            tile: tile,
                                            factoryIndex: factoryIndex,
                                            tileIndex: index,
                                            sourceId: factoryIndex
                                        };
                                        console.log('Setting drag data:', tileData);
                                        
                                        e.dataTransfer.setData('application/json', JSON.stringify(tileData));
                                        e.dataTransfer.effectAllowed = 'move';
                                        tileElement.classList.add('dragging');
                                        
                                        // Create drag ghost
                                        dragGhost = tileElement.cloneNode(true);
                                        dragGhost.classList.add('drag-ghost');
                                        dragGhost.style.width = '40px';
                                        dragGhost.style.height = '40px';
                                        document.body.appendChild(dragGhost);
                                        e.dataTransfer.setDragImage(dragGhost, 20, 20);
                                    }}
                                    onDragEnd={(e, tileElement) => {
                                        tileElement.classList.remove('dragging');
                                        if (dragGhost) {
                                            document.body.removeChild(dragGhost);
                                            dragGhost = null;
                                        }
                                    }}
                                />
                            );
                        })}
                    </div>
                </div>
            );
        }

        // Pattern Line Component with drop zones
        function PatternLine({ tiles, rowIndex, maxTiles, onTileClick, onDrop, selectedTile = null, onDestinationClick = null }) {
            const patternLineRef = React.useRef(null);
            
            useEffect(() => {
                const patternLine = patternLineRef.current;
                if (!patternLine) return;
                
                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('drag-over');
                };
                
                const handleDragLeave = (e) => {
                    e.currentTarget.classList.remove('drag-over');
                };
                
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    console.log('PatternLine drop event triggered');
                    
                    const tileData = e.dataTransfer.getData('application/json');
                    console.log('Tile data from drop:', tileData);
                    
                    if (tileData) {
                        const data = JSON.parse(tileData);
                        console.log('Parsed data:', data);
                        if (onDrop) {
                            console.log('Calling onDrop with:', data, rowIndex);
                            onDrop(data, rowIndex);
                        } else {
                            console.log('onDrop is not defined');
                        }
                    } else {
                        console.log('No tile data found in drop event');
                    }
                };
                
                patternLine.addEventListener('dragover', handleDragOver);
                patternLine.addEventListener('dragleave', handleDragLeave);
                patternLine.addEventListener('drop', handleDrop);
                
                return () => {
                    patternLine.removeEventListener('dragover', handleDragOver);
                    patternLine.removeEventListener('dragleave', handleDragLeave);
                    patternLine.removeEventListener('drop', handleDrop);
                };
            }, [onDrop, rowIndex, patternLineRef]);
            
            const emptySlots = Math.max(0, maxTiles - tiles.length);
            const isValidDestination = selectedTile && onDestinationClick;
            
            return (
                <div ref={patternLineRef} className={`pattern-line ${isValidDestination ? 'valid-drop' : ''}`}>
                    {tiles.map((tile, index) => (
                        <Tile 
                            key={index}
                            color={tile}
                            onClick={() => {
                                if (isValidDestination) {
                                    onDestinationClick('pattern', { rowIndex, tileIndex: index });
                                } else {
                                    onTileClick(rowIndex, index);
                                }
                            }}
                        />
                    ))}
                    {Array.from({ length: emptySlots }, (_, index) => (
                        <div 
                            key={`empty-${index}`}
                            className="tile"
                            style={{ backgroundColor: 'transparent', border: '2px dashed #d1d5db' }}
                            onClick={() => {
                                if (isValidDestination) {
                                    onDestinationClick('pattern', { rowIndex, tileIndex: tiles.length + index });
                                } else {
                                    onTileClick(rowIndex, tiles.length + index);
                                }
                            }}
                        />
                    ))}
                </div>
            );
        }

        // Wall Component with drop zones
        function Wall({ wall, onWallClick, onDrop, selectedTile = null, onDestinationClick = null }) {
            const wallRef = React.useRef(null);
            
            useEffect(() => {
                const wall = wallRef.current;
                if (!wall) return;
                
                const handleDragOver = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('drag-over');
                };
                
                const handleDragLeave = (e) => {
                    e.currentTarget.classList.remove('drag-over');
                };
                
                const handleDrop = (e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('drag-over');
                    
                    const tileData = e.dataTransfer.getData('application/json');
                    if (tileData) {
                        const data = JSON.parse(tileData);
                        const rowIndex = parseInt(e.currentTarget.dataset.row);
                        const colIndex = parseInt(e.currentTarget.dataset.col);
                        if (onDrop) {
                            onDrop(data, rowIndex, colIndex);
                        }
                    }
                };
                
                const cells = wall.querySelectorAll('.wall-cell');
                cells.forEach(cell => {
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('dragleave', handleDragLeave);
                    cell.addEventListener('drop', handleDrop);
                });
                
                return () => {
                    cells.forEach(cell => {
                        cell.removeEventListener('dragover', handleDragOver);
                        cell.removeEventListener('dragleave', handleDragLeave);
                        cell.removeEventListener('drop', handleDrop);
                    });
                };
            }, [onDrop]);
            
            return (
                <div ref={wallRef} className="wall">
                    {wall.map((row, rowIndex) => (
                        row.map((cell, colIndex) => {
                            const isValidDestination = selectedTile && onDestinationClick && !cell;
                            
                            return (
                                <div 
                                    key={`${rowIndex}-${colIndex}`}
                                    className={`wall-cell ${cell ? 'occupied' : ''} ${isValidDestination ? 'valid-drop' : ''}`}
                                    onClick={() => {
                                        if (isValidDestination) {
                                            onDestinationClick('wall', { rowIndex, colIndex });
                                        } else {
                                            onWallClick(rowIndex, colIndex);
                                        }
                                    }}
                                    data-row={rowIndex}
                                    data-col={colIndex}
                                >
                                    {cell && <Tile color={cell} />}
                                </div>
                            );
                        })
                    ))}
                </div>
            );
        }

        // Enhanced Player Board Component with active player indication
        function PlayerBoard({ 
            player, 
            playerIndex, 
            onPatternLineClick, 
            onWallClick, 
            onPatternLineDrop, 
            onWallDrop, 
            selectedTile = null, 
            onDestinationClick = null,
            isActive = false,
            onPlayerSwitch = null,
            canInteract = true,
            gameMode = 'sandbox'
        }) {
            const borderClass = isActive ? 'border-4 border-blue-500 bg-blue-50' : 'border-2 border-gray-300 bg-gray-50';
            const headerClass = isActive ? 'text-blue-700 font-bold' : 'text-gray-700';
            
            return (
                <div className={`${borderClass} p-4 rounded-lg mb-4 transition-all duration-200`}>
                    <div className="flex justify-between items-center mb-3">
                        <h4 className={`text-lg font-medium ${headerClass}`}>
                            Player {playerIndex + 1}
                            {isActive && <span className="ml-2 text-sm">👑 Active</span>}
                            <span className="ml-2 text-sm text-gray-500">Score: {player.score || 0}</span>
                        </h4>
                        
                        {onPlayerSwitch && canInteract && gameMode === 'sandbox' && (
                            <button
                                onClick={() => onPlayerSwitch(playerIndex)}
                                disabled={isActive}
                                className={`px-3 py-1 text-sm rounded transition-colors ${
                                    isActive 
                                        ? 'bg-blue-200 text-blue-800 cursor-not-allowed' 
                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                }`}
                            >
                                {isActive ? 'Playing' : 'Switch'}
                            </button>
                        )}
                    </div>
                    
                    {/* Pattern Lines */}
                    <div className="mb-4">
                        <h5 className="text-sm font-medium mb-2">Pattern Lines</h5>
                                                {player.pattern_lines.map((line, index) => (
                            <PatternLine 
                                key={index}
                                tiles={line}
                                rowIndex={index}
                                maxTiles={index + 1}
                                onTileClick={onPatternLineClick}
                                onDrop={onPatternLineDrop}
                                selectedTile={selectedTile}
                                onDestinationClick={onDestinationClick}
                            />
                        ))}
                    </div>

                    {/* Wall */}
                    <div className="mb-4">
                        <h5 className="text-sm font-medium mb-2">Wall</h5>
                        <Wall 
                            wall={player.wall}
                            onWallClick={onWallClick}
                            onDrop={onWallDrop}
                            selectedTile={selectedTile}
                            onDestinationClick={onDestinationClick}
                        />
                    </div>
                    
                    {/* Floor */}
                    <div>
                        <h5 className="text-sm font-medium mb-2">Floor</h5>
                        <div className="flex gap-1">
                            {player.floor.map((tile, index) => (
                                <Tile key={index} color={tile} />
                            ))}
                            {Array.from({ length: Math.max(0, 7 - player.floor.length) }, (_, index) => (
                                <div 
                                    key={`floor-empty-${index}`}
                                    className="tile"
                                    style={{ backgroundColor: 'transparent', border: '2px dashed #d1d5db' }}
                                />
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        // Status Message Component
        function StatusMessage({ type, message }) {
            const typeClasses = {
                success: 'status-success',
                error: 'status-error',
                warning: 'status-warning'
            };
            
            return (
                <div className={`text-center p-3 rounded-lg ${typeClasses[type] || 'text-gray-600'}`}>
                    {message}
                </div>
            );
        }

        // Move Option Component
        function MoveOption({ move, score, visits, onClick, isSelected }) {
            return (
                <div 
                    className={`move-option ${isSelected ? 'selected' : ''}`}
                    onClick={onClick}
                >
                    <div className="flex justify-between items-center">
                        <span className="font-medium">{move}</span>
                        <span className="text-sm">{score?.toFixed(2) || 'N/A'}</span>
                    </div>
                    {visits && <div className="text-xs text-gray-500">Visits: {visits}</div>}
                </div>
            );
        }

        // Main App Component
        function App() {
            const [sessionStatus, setSessionStatus] = useState('connecting');
            const [statusMessage, setStatusMessage] = useState('Initializing...');
            const [loading, setLoading] = useState(false);
            const [gameState, setGameState] = useState(null);
            const [analysis, setAnalysis] = useState(null);
            const [hint, setHint] = useState(null);
            const [selectedMove, setSelectedMove] = useState(null);
            const [fenString, setFenString] = useState('initial');
            
            // Enhanced game management state
            const [currentPlayer, setCurrentPlayer] = useState(0);
            const [playerCount, setPlayerCount] = useState(2);
            const [gameMode, setGameMode] = useState('sandbox'); // 'sandbox', 'analysis', 'setup'
            const [autoAdvanceTurn, setAutoAdvanceTurn] = useState(false);
            
            // D4.2 Advanced Sandbox Features
            const [variations, setVariations] = useState(new Map());
            const [currentVariation, setCurrentVariation] = useState('main');
            const [variationCounter, setVariationCounter] = useState(0);
            const [moveAnnotations, setMoveAnnotations] = useState(new Map());
            const [showVariationPanel, setShowVariationPanel] = useState(false);
            const [showAnnotationPanel, setShowAnnotationPanel] = useState(false);
            
            // D5: Game analysis state
            const [gameAnalysis, setGameAnalysis] = useState(null);
            
            // D6: Opening explorer state
            const [similarPositions, setSimilarPositions] = useState(null);
            const [popularContinuations, setPopularContinuations] = useState(null);
            
            // Click selection state
            const [selectedTile, setSelectedTile] = useState(null);
            const [selectionMode, setSelectionMode] = useState('none'); // 'none', 'tile', 'destination'

            // Initialize session and game state on component mount
            useEffect(() => {
                initializeSession().then(success => {
                    if (success) {
                        setSessionStatus('connected');
                        setStatusMessage('✅ Connected to API');
                        
                        // Fetch initial game state
                        getGameState('initial').then(state => {
                            if (state) {
                                setGameState(state);
                                setStatusMessage('✅ Game state loaded');
                            } else {
                                setStatusMessage('❌ Failed to load game state');
                            }
                        });
                    } else {
                        setSessionStatus('error');
                        setStatusMessage('❌ Failed to connect to API');
                    }
                });
            }, []);

            // Keyboard shortcuts for undo/redo
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') {
                            e.preventDefault();
                            undoMove();
                        } else if (e.key === 'y') {
                            e.preventDefault();
                            redoMove();
                        }
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        clearSelection();
                    }
                };
                
                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, []);

            // Analysis handlers
            const handleAnalyze = async () => {
                setLoading(true);
                setStatusMessage('🔍 Analyzing position...');
                
                const result = await analyzePosition(fenString);
                if (result) {
                    setAnalysis(result);
                    setStatusMessage('✅ Analysis complete');
                } else {
                    setStatusMessage('❌ Analysis failed');
                }
                
                setLoading(false);
            };

            const handleHint = async () => {
                setLoading(true);
                setStatusMessage('💡 Generating hint...');
                
                const result = await getHint(fenString);
                if (result) {
                    setHint(result);
                    setStatusMessage('✅ Hint generated');
                } else {
                    setStatusMessage('❌ Hint generation failed');
                }
                
                setLoading(false);
            };

            const handleNeuralAnalyze = async () => {
                setLoading(true);
                setStatusMessage('🧠 Neural analysis...');
                
                const result = await analyzeNeural(fenString);
                if (result) {
                    setAnalysis(result);
                    setStatusMessage('✅ Neural analysis complete');
                } else {
                    setStatusMessage('❌ Neural analysis failed');
                }
                
                setLoading(false);
            };

            // Enhanced move execution with player management
            const executeMove = async (moveData, playerId = null) => {
                if (sessionStatus !== 'connected') {
                    setStatusMessage('❌ Not connected to API');
                    return;
                }
                
                const activePlayer = playerId !== null ? playerId : currentPlayer;
                setLoading(true);
                setStatusMessage(`🎯 Player ${activePlayer + 1} executing move...`);
                
                const requestData = {
                    fen_string: stateToFen(),
                    move: moveData,
                    agent_id: activePlayer
                };
                
                console.log('DEBUG: Move data received:', moveData);
                console.log('DEBUG: Request data:', requestData);
                console.log('DEBUG: Active player:', activePlayer);
                
                try {
                    const response = await fetch(`${API_BASE}/execute_move`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': sessionId
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    const result = await response.json();
                    console.log('API response:', result);
                    
                    if (result.success) {
                        // Add to move history with player info
                        moveHistory.push({
                            move: moveData,
                            state: stateToFen(),
                            timestamp: Date.now(),
                            player: activePlayer,
                            description: formatMoveDescription(moveData)
                        });
                        
                        // Clear undo stack since we made a new move
                        undoStack = [];
                        
                        // Update game state
                        updateGameState(result.new_fen);
                        
                        setStatusMessage(`✅ Player ${activePlayer + 1} move executed: ${result.move_executed || formatMoveDescription(moveData)}`);
                        
                        // Advance turn if auto-advance is enabled and game isn't over
                        if (autoAdvanceTurn && !result.game_over && gameMode === 'sandbox') {
                            setTimeout(() => {
                                advanceTurn();
                            }, 1000);
                        }
                        
                        // Show engine response if available (only in analysis mode)
                        if (result.engine_response && gameMode === 'analysis') {
                            setTimeout(() => {
                                setStatusMessage(`🤖 Engine response: ${result.engine_response.move} (${result.engine_response.score.toFixed(2)})`);
                            }, 1000);
                        }
                        
                        // Check if game is over
                        if (result.game_over) {
                            setTimeout(() => {
                                setStatusMessage(`🏁 Game Over! Final scores: ${result.scores.join(' - ')}`);
                            }, 2000);
                        } else if (!autoAdvanceTurn) {
                            // Show whose turn it is next
                            setTimeout(() => {
                                setStatusMessage(`🎮 Player ${currentPlayer + 1}'s turn`);
                            }, 2000);
                        }
                    } else {
                        setStatusMessage(`❌ Player ${activePlayer + 1} move failed: ${result.error}`);
                    }
                } catch (error) {
                    setStatusMessage(`❌ Move execution error: ${error.message}`);
                }
                
                setLoading(false);
            };

            // Undo last move
            const undoMove = () => {
                if (moveHistory.length === 0) {
                    setStatusMessage('❌ No moves to undo');
                    return;
                }
                
                const lastMove = moveHistory.pop();
                undoStack.push(lastMove);
                
                // Restore previous state
                if (moveHistory.length > 0) {
                    const previousState = moveHistory[moveHistory.length - 1];
                    updateGameState(previousState.state);
                } else {
                    // Back to initial state
                    updateGameState('initial');
                }
                
                setStatusMessage('↶ Move undone');
            };

            // Redo move
            const redoMove = () => {
                if (undoStack.length === 0) {
                    setStatusMessage('❌ No moves to redo');
                    return;
                }
                
                const moveToRedo = undoStack.pop();
                executeMove(moveToRedo.move);
            };

            // Update game state from FEN
            const updateGameState = (fen) => {
                setFenString(fen);
                
                // Fetch new game state from API
                getGameState(fen).then(state => {
                    if (state) {
                        setGameState(state);
                    }
                });
            };

            // Convert current state to FEN
            const stateToFen = () => {
                return fenString;
            };

            // Convert tile color to type
            const getTileTypeFromColor = (color) => {
                const colorMap = {
                    'B': 0, // blue
                    'Y': 1, // yellow
                    'R': 2, // red
                    'K': 3, // black
                    'W': 4  // white
                };
                return colorMap[color] || 0;
            };

            // Format move description for display
            const formatMoveDescription = (move) => {
                const tileColors = ['red', 'blue', 'yellow', 'black', 'white'];
                const tileColor = tileColors[move.tile_type] || 'unknown';
                const source = move.source_id >= 0 ? `factory ${move.source_id}` : 'center';
                const destination = move.pattern_line_dest >= 0 ? `pattern line ${move.pattern_line_dest}` : 'floor';
                
                return `Take ${tileColor} from ${source} to ${destination}`;
            };

            // Handle pattern line drop
            const handlePatternLineDrop = (tileData, rowIndex) => {
                console.log('handlePatternLineDrop called with:', tileData, rowIndex);
                
                // Calculate how many tiles of this type are available
                let totalTilesAvailable = 0;
                if (tileData.sourceId >= 0) {
                    // From factory - count all tiles of this type in the factory
                    const factory = gameState.factories[tileData.sourceId];
                    totalTilesAvailable = factory.filter(tile => tile === tileData.tile).length;
                } else {
                    // From center - count all tiles of this type in center
                    totalTilesAvailable = gameState.center.filter(tile => tile === tileData.tile).length;
                }

                // Calculate placement for pattern line
                const maxForPatternLine = rowIndex + 1; // Pattern line 0 holds 1, line 1 holds 2, etc.
                const numToPattern = Math.min(totalTilesAvailable, maxForPatternLine);
                const numToFloor = Math.max(0, totalTilesAvailable - numToPattern);
                
                const move = {
                    source_id: tileData.sourceId,
                    tile_type: getTileTypeFromColor(tileData.tile),
                    pattern_line_dest: rowIndex,
                    num_to_pattern_line: numToPattern,
                    num_to_floor_line: numToFloor
                };
                
                console.log('Tile data:', tileData);
                console.log('Total tiles available:', totalTilesAvailable);
                console.log('Calculated placement - pattern:', numToPattern, 'floor:', numToFloor);
                console.log('Generated move:', move);
                
                executeMove(move);
            };

            // Handle wall drop
            const handleWallDrop = (tileData, rowIndex, colIndex) => {
                setStatusMessage('🎯 Wall placement not yet implemented');
            };

            // Handle pattern line click
            const handlePatternLineClick = (rowIndex, tileIndex) => {
                setStatusMessage(`🎯 Pattern line ${rowIndex} clicked`);
            };

            // Handle wall click
            const handleWallClick = (rowIndex, colIndex) => {
                setStatusMessage(`🎯 Wall cell ${rowIndex}, ${colIndex} clicked`);
            };

            // Click selection handlers
            const handleTileSelection = (tileData) => {
                // Clear any existing selection
                clearSelection();
                
                // Set new selection
                setSelectedTile(tileData);
                setSelectionMode('tile');
                setStatusMessage(`✅ Selected ${tileData.tile} tile from ${tileData.sourceId >= 0 ? `factory ${tileData.sourceId + 1}` : 'center'}`);
            };

            const handleDestinationClick = (destinationType, destinationData) => {
                if (!selectedTile) {
                    setStatusMessage('❌ No tile selected. Click a tile first.');
                    return;
                }

                // Calculate how many tiles of this type are available
                let totalTilesAvailable = 0;
                if (selectedTile.sourceId >= 0) {
                    // From factory - count all tiles of this type in the factory
                    const factory = gameState.factories[selectedTile.sourceId];
                    totalTilesAvailable = factory.filter(tile => tile === selectedTile.tile).length;
                } else {
                    // From center - count all tiles of this type in center
                    totalTilesAvailable = gameState.center.filter(tile => tile === selectedTile.tile).length;
                }

                // Calculate placement based on destination
                let numToPattern = 0;
                let numToFloor = 0;
                
                if (destinationType === 'pattern') {
                    const maxForPatternLine = destinationData.rowIndex + 1; // Pattern line 0 holds 1, line 1 holds 2, etc.
                    numToPattern = Math.min(totalTilesAvailable, maxForPatternLine);
                    numToFloor = Math.max(0, totalTilesAvailable - numToPattern);
                } else if (destinationType === 'wall') {
                    // Wall placement not implemented yet, put all on floor
                    numToPattern = 0;
                    numToFloor = totalTilesAvailable;
                }

                // Execute the move
                const move = {
                    source_id: selectedTile.sourceId,
                    tile_type: getTileTypeFromColor(selectedTile.tile),
                    pattern_line_dest: destinationType === 'pattern' ? destinationData.rowIndex : -1,
                    wall_row: destinationType === 'wall' ? destinationData.rowIndex : -1,
                    wall_col: destinationType === 'wall' ? destinationData.colIndex : -1,
                    num_to_pattern_line: numToPattern,
                    num_to_floor_line: numToFloor
                };

                console.log('DEBUG: Selected tile:', selectedTile);
                console.log('DEBUG: Destination:', destinationType, destinationData);
                console.log('DEBUG: Total tiles available:', totalTilesAvailable);
                console.log('DEBUG: Calculated placement - pattern:', numToPattern, 'floor:', numToFloor);
                console.log('DEBUG: Generated move:', move);

                executeMove(move);
                clearSelection();
            };

            const clearSelection = () => {
                setSelectedTile(null);
                setSelectionMode('none');
            };

            // Enhanced turn management functions
            const advanceTurn = () => {
                const nextPlayer = (currentPlayer + 1) % playerCount;
                setCurrentPlayer(nextPlayer);
                setStatusMessage(`🎮 Player ${nextPlayer + 1}'s turn`);
                console.log('Advanced turn to player:', nextPlayer);
            };

            const switchToPlayer = (playerId) => {
                if (playerId >= 0 && playerId < playerCount) {
                    setCurrentPlayer(playerId);
                    setStatusMessage(`🎮 Switched to Player ${playerId + 1}`);
                    console.log('Switched to player:', playerId);
                }
            };

            const resetGame = async () => {
                if (loading) return;
                
                setLoading(true);
                setStatusMessage('🔄 Resetting game...');
                
                try {
                    // Reset to initial state
                    setFenString('initial');
                    setCurrentPlayer(0);
                    moveHistory = [];
                    undoStack = [];
                    setSelectedTile(null);
                    setSelectionMode('none');
                    setAnalysis(null);
                    setHint(null);
                    
                    // Get fresh initial state
                    const state = await getGameState('initial');
                    if (state) {
                        setGameState(state);
                        setStatusMessage('✅ Game reset - Player 1\'s turn');
                    }
                } catch (error) {
                    setStatusMessage(`❌ Reset failed: ${error.message}`);
                }
                
                setLoading(false);
            };

            const createNewGame = async (newPlayerCount = 2) => {
                // Only 2-player games supported
                if (newPlayerCount !== 2) {
                    setStatusMessage('❌ Only 2-player games are supported');
                    return;
                }
                if (loading) return;
                
                setLoading(true);
                setStatusMessage(`🆕 Creating ${newPlayerCount}-player game...`);
                
                try {
                    // Call API to create new game state
                    const response = await fetch(`${API_BASE}/create_game`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': sessionId
                        },
                        body: JSON.stringify({
                            player_count: newPlayerCount
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        setPlayerCount(newPlayerCount);
                        setCurrentPlayer(0);
                        setFenString(result.fen_string || 'initial');
                        moveHistory = [];
                        undoStack = [];
                        setSelectedTile(null);
                        setSelectionMode('none');
                        setAnalysis(null);
                        setHint(null);
                        
                        // Reset variation state
                        setVariations(new Map());
                        setCurrentVariation('main');
                        setVariationCounter(0);
                        setMoveAnnotations(new Map());
                        
                        const state = await getGameState(result.fen_string || 'initial');
                        if (state) {
                            setGameState(state);
                            setStatusMessage(`✅ New ${newPlayerCount}-player game created - Player 1's turn`);
                        }
                    } else {
                        setStatusMessage(`❌ Failed to create game: ${result.error}`);
                    }
                } catch (error) {
                    // Fallback to simple reset
                    console.log('Create game API not available, falling back to reset');
                    setPlayerCount(newPlayerCount);
                    await resetGame();
                }
                
                setLoading(false);
            };

            // D4.2 Advanced Sandbox Functions
            const createVariation = (fromMoveIndex, name = null) => {
                const variationId = name || `variation_${variationCounter + 1}`;
                const baseHistory = moveHistory.slice(0, fromMoveIndex + 1);
                
                const newVariations = new Map(variations);
                newVariations.set(variationId, {
                    name: variationId,
                    baseMoveIndex: fromMoveIndex,
                    moves: [],
                    state: fenString,
                    timestamp: Date.now()
                });
                
                setVariations(newVariations);
                setVariationCounter(variationCounter + 1);
                setStatusMessage(`✅ Created variation: ${variationId}`);
                
                return variationId;
            };

            const switchToVariation = (variationId) => {
                if (variations.has(variationId)) {
                    setCurrentVariation(variationId);
                    const variation = variations.get(variationId);
                    
                    // Load the variation's state
                    updateGameState(variation.state);
                    
                    // Restore move history to the base point
                    const baseHistory = moveHistory.slice(0, variation.baseMoveIndex + 1);
                    moveHistory = [...baseHistory, ...variation.moves];
                    undoStack = [];
                    
                    setStatusMessage(`✅ Switched to variation: ${variationId}`);
                }
            };

            const saveCurrentAsVariation = () => {
                const variationId = createVariation(moveHistory.length - 1);
                switchToVariation(variationId);
            };

            const exportPosition = () => {
                const positionData = {
                    fen: fenString,
                    moveHistory: moveHistory,
                    variations: Array.from(variations.entries()),
                    annotations: Array.from(moveAnnotations.entries()),
                    currentVariation: currentVariation,
                    playerCount: playerCount,
                    currentPlayer: currentPlayer,
                    timestamp: Date.now(),
                    description: `Azul position exported from ${new Date().toLocaleString()}`
                };
                
                const blob = new Blob([JSON.stringify(positionData, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `azul_position_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                setStatusMessage('✅ Position exported successfully');
            };

            const importPosition = (file) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Load position data
                        if (data.fen) {
                            updateGameState(data.fen);
                        }
                        
                        if (data.moveHistory) {
                            moveHistory = data.moveHistory;
                        }
                        
                        if (data.variations) {
                            setVariations(new Map(data.variations));
                        }
                        
                        if (data.annotations) {
                            setMoveAnnotations(new Map(data.annotations));
                        }
                        
                        if (data.currentVariation) {
                            setCurrentVariation(data.currentVariation);
                        }
                        
                        if (data.playerCount) {
                            setPlayerCount(data.playerCount);
                        }
                        
                        if (data.currentPlayer !== undefined) {
                            setCurrentPlayer(data.currentPlayer);
                        }
                        
                        setStatusMessage('✅ Position imported successfully');
                    } catch (error) {
                        setStatusMessage(`❌ Invalid position file: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            };

            const addMoveAnnotation = (moveIndex, annotation) => {
                const newAnnotations = new Map(moveAnnotations);
                newAnnotations.set(moveIndex, {
                    annotation: annotation,
                    timestamp: Date.now(),
                    player: moveHistory[moveIndex]?.player || 0
                });
                setMoveAnnotations(newAnnotations);
                setStatusMessage(`✅ Added annotation to move ${moveIndex + 1}`);
            };

            const getMoveAnnotation = (moveIndex) => {
                return moveAnnotations.get(moveIndex);
            };

            // D5: Game analysis functions
            const uploadGameLog = async () => {
                const format = document.getElementById('game-format').value;
                const content = document.getElementById('game-log-content').value;
                
                if (!content.trim()) {
                    setStatusMessage('❌ Please enter game log content');
                    return;
                }
                
                setLoading(true);
                setStatusMessage('📤 Uploading and analyzing game log...');
                
                try {
                    const response = await fetch(`${API_BASE}/upload_game_log`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': sessionId
                        },
                        body: JSON.stringify({
                            game_format: format,
                            game_content: content
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        // Now analyze the game
                        const analysisResponse = await fetch(`${API_BASE}/analyze_game`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Session-ID': sessionId
                            },
                            body: JSON.stringify({
                                game_data: result.parsed_data,
                                include_blunder_analysis: true,
                                include_position_analysis: true,
                                analysis_depth: 3
                            })
                        });
                        
                        const analysisResult = await analysisResponse.json();
                        
                        if (analysisResult.success) {
                            setGameAnalysis(analysisResult);
                            setStatusMessage(`✅ Game analyzed: ${analysisResult.summary.blunder_count} blunders found`);
                        } else {
                            setStatusMessage(`❌ Analysis failed: ${analysisResult.error}`);
                        }
                    } else {
                        setStatusMessage(`❌ Upload failed: ${result.error}`);
                    }
                } catch (error) {
                    setStatusMessage(`❌ Error: ${error.message}`);
                }
                
                setLoading(false);
            };

            const jumpToMove = (moveAnalysis) => {
                if (moveAnalysis.position) {
                    updateGameState(moveAnalysis.position);
                    setStatusMessage(`🎯 Jumped to move ${moveAnalysis.move_index + 1} (P${moveAnalysis.player + 1})`);
                    
                    // Show blunder details if it's a blunder
                    if (moveAnalysis.is_blunder) {
                        setTimeout(() => {
                            alert(`Blunder Details:\n\nMove: ${formatMoveDescription(moveAnalysis.move)}\nSeverity: ${moveAnalysis.blunder_severity.toFixed(2)}\n\nBest move would have been: ${moveAnalysis.analysis?.best_move || 'Unknown'}`);
                        }, 500);
                    }
                } else {
                    setStatusMessage('❌ Position data not available for this move');
                }
            };

            // D6: Opening explorer functions
            const findSimilarPositions = async () => {
                const threshold = parseFloat(document.getElementById('similarity-threshold').value) || 0.8;
                
                setLoading(true);
                setStatusMessage('🔍 Finding similar positions...');
                
                try {
                    const response = await fetch(`${API_BASE}/similar_positions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': sessionId
                        },
                        body: JSON.stringify({
                            fen_string: stateToFen(),
                            similarity_threshold: threshold,
                            limit: 10
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        setSimilarPositions(result.similar_positions);
                        setStatusMessage(`✅ Found ${result.similar_positions.length} similar positions`);
                    } else {
                        setStatusMessage(`❌ Failed to find similar positions: ${result.error}`);
                    }
                } catch (error) {
                    setStatusMessage(`❌ Error: ${error.message}`);
                }
                
                setLoading(false);
            };

            const loadSimilarPosition = (position) => {
                updateGameState(position.fen_string);
                setStatusMessage(`🎯 Loaded similar position (${(position.similarity * 100).toFixed(1)}% similar)`);
            };

            const getPopularContinuations = async () => {
                setLoading(true);
                setStatusMessage('📊 Getting popular continuations...');
                
                try {
                    const response = await fetch(`${API_BASE}/popular_continuations`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': sessionId
                        },
                        body: JSON.stringify({
                            fen_string: stateToFen(),
                            limit: 5
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        setPopularContinuations(result.continuations);
                        setStatusMessage(`✅ Found ${result.continuations.length} popular continuations`);
                    } else {
                        setStatusMessage(`❌ Failed to get continuations: ${result.error}`);
                    }
                } catch (error) {
                    setStatusMessage(`❌ Error: ${error.message}`);
                }
                
                setLoading(false);
            };

            const playContinuation = (continuation) => {
                executeMove(continuation.move);
                setStatusMessage(`🎯 Played continuation: ${continuation.description}`);
            };

            const addCurrentPosition = async () => {
                setLoading(true);
                setStatusMessage('➕ Adding current position to database...');
                
                try {
                    const response = await fetch(`${API_BASE}/add_to_database`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': sessionId
                        },
                        body: JSON.stringify({
                            fen_string: stateToFen(),
                            metadata: {
                                added_by: 'web_ui',
                                timestamp: Date.now(),
                                game_mode: gameMode
                            },
                            frequency: 1
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        setStatusMessage(`✅ Position added to database (ID: ${result.position_id})`);
                    } else {
                        setStatusMessage(`❌ Failed to add position: ${result.error}`);
                    }
                } catch (error) {
                    setStatusMessage(`❌ Error: ${error.message}`);
                }
                
                setLoading(false);
            };

            // Check if a destination is valid for the selected tile
            const isValidDestination = (destinationType, destinationData) => {
                if (!selectedTile) return false;
                
                // For now, allow all destinations
                // In the future, add validation logic here
                return true;
            };

            return (
                <div className="container mx-auto p-6">
                    <div className="text-center mb-8">
                        <h1 className="text-3xl font-bold text-gray-900 mb-2">
                            Azul Solver & Analysis Toolkit
                        </h1>
                        <p className="text-gray-600 mb-4">
                            Interactive game analysis with live hints and exact evaluation
                        </p>
                        <StatusMessage 
                            type={sessionStatus === 'connected' ? 'success' : sessionStatus === 'error' ? 'error' : 'warning'}
                            message={statusMessage || 'Initializing...'}
                        />
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        {/* Game Board */}
                        <div className="lg:col-span-2">
                            <div className="bg-white p-6 rounded-lg shadow">
                                <h2 className="text-xl font-semibold mb-4">Game Board</h2>
                                
                                {!gameState ? (
                                    <div className="text-center py-8">
                                        <div className="text-gray-500">Loading game state...</div>
                                    </div>
                                ) : (
                                    <>
                                        {/* Factories */}
                                        <div className="mb-6">
                                            <h3 className="text-lg font-medium mb-3">Factories</h3>
                                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                                {gameState.factories.map((factory, index) => (
                                                    <Factory 
                                                        key={index}
                                                        tiles={factory}
                                                        factoryIndex={index}
                                                        onTileClick={(tile, tileIndex) => {
                                                            setStatusMessage(`🎯 Selected ${tile} tile from factory ${index + 1}`);
                                                        }}
                                                        selectedTile={selectedTile}
                                                        onTileSelection={handleTileSelection}
                                                    />
                                                ))}
                                            </div>
                                        </div>

                                        {/* Center */}
                                        <div className="mb-6">
                                            <h3 className="text-lg font-medium mb-3">Center</h3>
                                            <div className="flex gap-2">
                                                {gameState.center.map((tile, index) => {
                                                    const tileData = {
                                                        tile: tile,
                                                        sourceId: -1, // -1 indicates center pool
                                                        tileIndex: index
                                                    };
                                                    const isSelected = selectedTile && 
                                                        selectedTile.tile === tile && 
                                                        selectedTile.sourceId === -1 && 
                                                        selectedTile.tileIndex === index;
                                                    
                                                    return (
                                                        <Tile 
                                                            key={index}
                                                            color={tile}
                                                            draggable={tile !== 'W'}
                                                            isSelected={isSelected}
                                                            onClick={() => handleTileSelection(tileData)}
                                                            onDragStart={(e, tileElement) => {
                                                                const tileData = {
                                                                    tile: tile,
                                                                    sourceId: -1, // -1 indicates center pool
                                                                    tileIndex: index
                                                                };
                                                                e.dataTransfer.setData('application/json', JSON.stringify(tileData));
                                                                e.dataTransfer.effectAllowed = 'move';
                                                                tileElement.classList.add('dragging');
                                                                
                                                                // Create drag ghost
                                                                dragGhost = tileElement.cloneNode(true);
                                                                dragGhost.classList.add('drag-ghost');
                                                                dragGhost.classList.add('drag-ghost');
                                                                dragGhost.style.width = '40px';
                                                                dragGhost.style.height = '40px';
                                                                document.body.appendChild(dragGhost);
                                                                e.dataTransfer.setDragImage(dragGhost, 20, 20);
                                                            }}
                                                            onDragEnd={(e, tileElement) => {
                                                                tileElement.classList.remove('dragging');
                                                                if (dragGhost) {
                                                                    document.body.removeChild(dragGhost);
                                                                    dragGhost = null;
                                                                }
                                                            }}
                                                        />
                                                    );
                                                })}
                                            </div>
                                        </div>

                                        {/* Player Boards */}
                                        <div>
                                            <h3 className="text-lg font-medium mb-3">Player Boards</h3>
                                            {gameState.players.map((player, index) => (
                                                <PlayerBoard 
                                                    key={index}
                                                    player={player}
                                                    playerIndex={index}
                                                    onPatternLineClick={handlePatternLineClick}
                                                    onWallClick={handleWallClick}
                                                    onPatternLineDrop={handlePatternLineDrop}
                                                    onWallDrop={handleWallDrop}
                                                    selectedTile={selectedTile}
                                                    onDestinationClick={handleDestinationClick}
                                                    isActive={index === currentPlayer}
                                                    onPlayerSwitch={switchToPlayer}
                                                    canInteract={!loading}
                                                    gameMode={gameMode}
                                                />
                                            ))}
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>

                        {/* Analysis Panel */}
                        <div className="space-y-6">
                            {/* Game Management Controls */}
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="text-lg font-medium mb-4">🎮 Game Management</h3>
                                
                                {/* Current Game Status */}
                                <div className="mb-4 p-3 bg-gray-50 rounded">
                                    <div className="flex justify-between items-center mb-2">
                                        <span className="font-medium">Current Player:</span>
                                        <span className={`px-2 py-1 rounded text-sm font-bold ${
                                            loading ? 'bg-gray-200 text-gray-600' : 'bg-blue-200 text-blue-800'
                                        }`}>
                                            Player {currentPlayer + 1} {loading ? '(Moving...)' : '👑'}
                                        </span>
                                    </div>
                                    <div className="flex justify-between items-center mb-2">
                                        <span className="font-medium">Mode:</span>
                                        <select 
                                            value={gameMode} 
                                            onChange={(e) => setGameMode(e.target.value)}
                                            disabled={loading}
                                            className="px-2 py-1 rounded border text-sm"
                                        >
                                            <option value="sandbox">🎮 Sandbox</option>
                                            <option value="analysis">🔍 Analysis</option>
                                            <option value="setup">⚙️ Setup</option>
                                        </select>
                                    </div>
                                    <div className="flex justify-between items-center">
                                        <span className="font-medium">Players:</span>
                                        <span className="text-sm">{playerCount} players</span>
                                    </div>
                                </div>
                                
                                {/* Player Controls */}
                                <div className="mb-4">
                                    <h4 className="text-md font-medium mb-2">Player Controls</h4>
                                    <div className="grid grid-cols-2 gap-2 mb-3">
                                        {Array.from({ length: playerCount }, (_, i) => (
                                            <button
                                                key={i}
                                                onClick={() => switchToPlayer(i)}
                                                disabled={loading || i === currentPlayer}
                                                className={`px-3 py-2 text-sm rounded transition-colors ${
                                                    i === currentPlayer
                                                        ? 'bg-blue-500 text-white font-bold cursor-not-allowed'
                                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                }`}
                                            >
                                                Player {i + 1} {i === currentPlayer ? '👑' : ''}
                                            </button>
                                        ))}
                                    </div>
                                    <div className="flex items-center gap-2 text-sm">
                                        <input
                                            type="checkbox"
                                            id="auto-advance"
                                            checked={autoAdvanceTurn}
                                            onChange={(e) => setAutoAdvanceTurn(e.target.checked)}
                                            disabled={loading}
                                        />
                                        <label htmlFor="auto-advance" className="text-gray-600">
                                            Auto-advance turns
                                        </label>
                                    </div>
                                </div>
                                
                                {/* Game Setup Controls */}
                                <div className="mb-4">
                                    <h4 className="text-md font-medium mb-2">Game Setup</h4>
                                    <div className="grid grid-cols-2 gap-2 mb-2">
                                        <button
                                            onClick={resetGame}
                                            disabled={loading}
                                            className="bg-yellow-600 text-white py-2 px-3 rounded hover:bg-yellow-700 disabled:opacity-50 text-sm"
                                        >
                                            🔄 Reset Game
                                        </button>
                                        <button
                                            onClick={() => createNewGame(2)}
                                            disabled={loading}
                                            className="bg-green-600 text-white py-2 px-3 rounded hover:bg-green-700 disabled:opacity-50 text-sm"
                                        >
                                            🆕 New 2P Game
                                        </button>
                                    </div>
                                    <div className="text-sm text-gray-600 mb-2">
                                        Only 2-player games supported
                                    </div>
                                </div>
                                
                                <div className="text-xs text-gray-500">
                                    <p>💡 Click player buttons to switch active player</p>
                                    <p>🎮 Sandbox: Manual play | 🔍 Analysis: Engine assistance | ⚙️ Setup: Board configuration</p>
                                </div>
                            </div>
                            
                            {/* D4.2 Advanced Sandbox Features */}
                            {gameMode === 'sandbox' && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-4">🌳 Advanced Sandbox</h3>
                                    
                                    {/* Variation Management */}
                                    <div className="mb-4">
                                        <h4 className="text-md font-medium mb-2">Variation Management</h4>
                                        <div className="grid grid-cols-2 gap-2 mb-3">
                                            <button
                                                onClick={() => createVariation(moveHistory.length - 1)}
                                                disabled={loading || moveHistory.length === 0}
                                                className="bg-purple-600 text-white py-2 px-3 rounded hover:bg-purple-700 disabled:opacity-50 text-sm"
                                            >
                                                🆕 Create Variation
                                            </button>
                                            <button
                                                onClick={() => setShowVariationPanel(!showVariationPanel)}
                                                disabled={loading || variations.size === 0}
                                                className="bg-indigo-600 text-white py-2 px-3 rounded hover:bg-indigo-700 disabled:opacity-50 text-sm"
                                            >
                                                📋 Show Variations ({variations.size})
                                            </button>
                                        </div>
                                        
                                        {showVariationPanel && variations.size > 0 && (
                                            <div className="bg-gray-50 p-3 rounded mb-3">
                                                <h5 className="text-sm font-medium mb-2">Available Variations:</h5>
                                                <div className="space-y-1">
                                                    {Array.from(variations.keys()).map((variationId) => (
                                                        <div key={variationId} className="flex justify-between items-center">
                                                            <span className="text-sm">{variationId}</span>
                                                            <button
                                                                onClick={() => switchToVariation(variationId)}
                                                                disabled={currentVariation === variationId}
                                                                className={`px-2 py-1 text-xs rounded ${
                                                                    currentVariation === variationId
                                                                        ? 'bg-green-200 text-green-800 cursor-not-allowed'
                                                                        : 'bg-blue-200 text-blue-700 hover:bg-blue-300'
                                                                }`}
                                                            >
                                                                {currentVariation === variationId ? 'Active' : 'Switch'}
                                                            </button>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {/* Position Export/Import */}
                                    <div className="mb-4">
                                        <h4 className="text-md font-medium mb-2">Position Management</h4>
                                        <div className="grid grid-cols-2 gap-2 mb-3">
                                            <button
                                                onClick={exportPosition}
                                                disabled={loading}
                                                className="bg-green-600 text-white py-2 px-3 rounded hover:bg-green-700 disabled:opacity-50 text-sm"
                                            >
                                                📤 Export Position
                                            </button>
                                            <label className="bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700 disabled:opacity-50 text-sm cursor-pointer text-center">
                                                📥 Import Position
                                                <input
                                                    type="file"
                                                    accept=".json"
                                                    onChange={(e) => {
                                                        if (e.target.files[0]) {
                                                            importPosition(e.target.files[0]);
                                                        }
                                                    }}
                                                    className="hidden"
                                                />
                                            </label>
                                        </div>
                                    </div>
                                    
                                    {/* Move Annotations */}
                                    <div className="mb-4">
                                        <h4 className="text-md font-medium mb-2">Move Annotations</h4>
                                        <div className="grid grid-cols-2 gap-2">
                                            <button
                                                onClick={() => setShowAnnotationPanel(!showAnnotationPanel)}
                                                disabled={loading || moveAnnotations.size === 0}
                                                className="bg-yellow-600 text-white py-2 px-3 rounded hover:bg-yellow-700 disabled:opacity-50 text-sm"
                                            >
                                                📝 Show Annotations ({moveAnnotations.size})
                                            </button>
                                            <button
                                                onClick={() => {
                                                    const annotation = prompt('Enter annotation for current position:');
                                                    if (annotation) {
                                                        addMoveAnnotation(moveHistory.length - 1, annotation);
                                                    }
                                                }}
                                                disabled={loading}
                                                className="bg-orange-600 text-white py-2 px-3 rounded hover:bg-orange-700 disabled:opacity-50 text-sm"
                                            >
                                                ✏️ Add Annotation
                                            </button>
                                        </div>
                                        
                                        {showAnnotationPanel && moveAnnotations.size > 0 && (
                                            <div className="bg-gray-50 p-3 rounded mt-3">
                                                <h5 className="text-sm font-medium mb-2">Move Annotations:</h5>
                                                <div className="space-y-2 max-h-32 overflow-y-auto">
                                                    {Array.from(moveAnnotations.entries()).map(([moveIndex, annotation]) => (
                                                        <div key={moveIndex} className="text-xs p-2 bg-white rounded">
                                                            <div className="font-medium">Move {moveIndex + 1}:</div>
                                                            <div className="text-gray-600">{annotation.annotation}</div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    
                                    <div className="text-xs text-gray-500">
                                        <p>🌳 Create variations to explore different move sequences</p>
                                        <p>📤 Export/import positions to save and share games</p>
                                        <p>📝 Add annotations to document your analysis</p>
                                    </div>
                                </div>
                            )}
                            
                            {/* D5: Replay Annotator */}
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="text-lg font-medium mb-4">📊 Replay Annotator</h3>
                                
                                {/* Game Log Upload */}
                                <div className="mb-4">
                                    <h4 className="text-md font-medium mb-2">Upload Game Log</h4>
                                    <div className="space-y-2">
                                        <select 
                                            id="game-format"
                                            className="w-full px-3 py-2 border rounded text-sm"
                                            defaultValue="json"
                                        >
                                            <option value="json">JSON Format</option>
                                            <option value="text">Text Format</option>
                                        </select>
                                        <textarea 
                                            id="game-log-content"
                                            placeholder="Paste your game log here..."
                                            className="w-full h-32 px-3 py-2 border rounded text-sm font-mono"
                                        />
                                        <button
                                            onClick={uploadGameLog}
                                            disabled={loading}
                                            className="w-full bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700 disabled:opacity-50 text-sm"
                                        >
                                            📤 Upload & Analyze
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Game Analysis Results */}
                                {gameAnalysis && (
                                    <div className="mb-4">
                                        <h4 className="text-md font-medium mb-2">Analysis Results</h4>
                                        <div className="bg-gray-50 p-3 rounded mb-3">
                                            <div className="grid grid-cols-2 gap-4 text-sm">
                                                <div>
                                                    <strong>Total Moves:</strong> {gameAnalysis.summary.total_moves}
                                                </div>
                                                <div>
                                                    <strong>Blunders:</strong> {gameAnalysis.summary.blunder_count}
                                                </div>
                                                <div>
                                                    <strong>Blunder %:</strong> {gameAnalysis.summary.blunder_percentage.toFixed(1)}%
                                                </div>
                                                <div>
                                                    <strong>Avg Severity:</strong> {gameAnalysis.summary.average_blunder_severity.toFixed(2)}
                                                </div>
                                            </div>
                                        </div>
                                        
                                        {/* Timeline */}
                                        <div className="max-h-40 overflow-y-auto">
                                            <h5 className="text-sm font-medium mb-2">Move Timeline:</h5>
                                            <div className="space-y-1">
                                                {gameAnalysis.analysis.map((moveAnalysis, index) => (
                                                    <div 
                                                        key={index}
                                                        className={`text-xs p-2 rounded cursor-pointer transition-colors ${
                                                            moveAnalysis.is_blunder 
                                                                ? 'bg-red-100 border-l-4 border-red-500' 
                                                                : 'bg-gray-50'
                                                        }`}
                                                        onClick={() => jumpToMove(moveAnalysis)}
                                                        title={moveAnalysis.is_blunder ? 'Click to view blunder details' : 'Click to view move'}
                                                    >
                                                        <div className="flex justify-between items-center">
                                                            <span className="font-medium">
                                                                Move {index + 1} (P{moveAnalysis.player + 1})
                                                            </span>
                                                            <span className={`px-2 py-1 rounded text-xs ${
                                                                moveAnalysis.is_blunder 
                                                                    ? 'bg-red-200 text-red-800' 
                                                                    : 'bg-green-200 text-green-800'
                                                            }`}>
                                                                {moveAnalysis.is_blunder ? '⚠️ Blunder' : '✅ Good'}
                                                            </span>
                                                        </div>
                                                        {moveAnalysis.is_blunder && (
                                                            <div className="text-red-700 text-xs mt-1">
                                                                Severity: {moveAnalysis.blunder_severity.toFixed(2)}
                                                            </div>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                <div className="text-xs text-gray-500">
                                    <p>📊 Upload game logs to analyze for blunders</p>
                                    <p>⚠️ Blunders are highlighted with severity ratings</p>
                                    <p>🎯 Click moves to jump to positions</p>
                                </div>
                            </div>
                            
                            {/* D6: Opening Explorer */}
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="text-lg font-medium mb-4">🌳 Opening Explorer</h3>
                                
                                {/* Position Search */}
                                <div className="mb-4">
                                    <h4 className="text-md font-medium mb-2">Find Similar Positions</h4>
                                    <div className="space-y-2">
                                        <input
                                            type="text"
                                            id="similarity-threshold"
                                            placeholder="Similarity threshold (0.0-1.0)"
                                            defaultValue="0.8"
                                            className="w-full px-3 py-2 border rounded text-sm"
                                        />
                                        <button
                                            onClick={findSimilarPositions}
                                            disabled={loading}
                                            className="w-full bg-green-600 text-white py-2 px-3 rounded hover:bg-green-700 disabled:opacity-50 text-sm"
                                        >
                                            🔍 Find Similar
                                        </button>
                                    </div>
                                </div>
                                
                                {/* Similar Positions Results */}
                                {similarPositions && similarPositions.length > 0 && (
                                    <div className="mb-4">
                                        <h4 className="text-md font-medium mb-2">Similar Positions</h4>
                                        <div className="max-h-32 overflow-y-auto space-y-1">
                                            {similarPositions.map((position, index) => (
                                                <div 
                                                    key={index}
                                                    className="text-xs p-2 bg-gray-50 rounded cursor-pointer hover:bg-gray-100"
                                                    onClick={() => loadSimilarPosition(position)}
                                                    title="Click to load position"
                                                >
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-medium">Position {index + 1}</span>
                                                        <span className="text-green-600">
                                                            {(position.similarity * 100).toFixed(1)}% similar
                                                        </span>
                                                    </div>
                                                    <div className="text-gray-600">
                                                        Frequency: {position.frequency} games
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                
                                {/* Popular Continuations */}
                                <div className="mb-4">
                                    <h4 className="text-md font-medium mb-2">Popular Continuations</h4>
                                    <button
                                        onClick={getPopularContinuations}
                                        disabled={loading}
                                        className="w-full bg-blue-600 text-white py-2 px-3 rounded hover:bg-blue-700 disabled:opacity-50 text-sm"
                                    >
                                        📊 Get Continuations
                                    </button>
                                    
                                    {popularContinuations && popularContinuations.length > 0 && (
                                        <div className="mt-3 max-h-32 overflow-y-auto space-y-1">
                                            {popularContinuations.map((continuation, index) => (
                                                <div 
                                                    key={index}
                                                    className="text-xs p-2 bg-blue-50 rounded cursor-pointer hover:bg-blue-100"
                                                    onClick={() => playContinuation(continuation)}
                                                    title="Click to play this continuation"
                                                >
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-medium">{continuation.description}</span>
                                                        <span className="text-blue-600">
                                                            {(continuation.win_rate * 100).toFixed(1)}% wins
                                                        </span>
                                                    </div>
                                                    <div className="text-gray-600">
                                                        Played {continuation.frequency} times
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                                
                                {/* Add Current Position */}
                                <div className="mb-4">
                                    <h4 className="text-md font-medium mb-2">Add to Database</h4>
                                    <button
                                        onClick={addCurrentPosition}
                                        disabled={loading}
                                        className="w-full bg-purple-600 text-white py-2 px-3 rounded hover:bg-purple-700 disabled:opacity-50 text-sm"
                                    >
                                        ➕ Add Current Position
                                    </button>
                                </div>
                                
                                <div className="text-xs text-gray-500">
                                    <p>🌳 Find similar positions in the database</p>
                                    <p>📊 Get popular continuations for positions</p>
                                    <p>➕ Add positions to build the database</p>
                                </div>
                            </div>
                            
                            {/* Analysis Controls */}
                            <div className="bg-white p-4 rounded-lg shadow">
                                <h3 className="text-lg font-medium mb-4">🔍 Analysis Controls</h3>
                                <div className="space-y-3">
                                    <button 
                                        onClick={handleAnalyze}
                                        disabled={loading || sessionStatus !== 'connected'}
                                        className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:opacity-50"
                                    >
                                        {loading ? 'Analyzing...' : 'Exact Analysis (Depth-3)'}
                                    </button>
                                    <button 
                                        onClick={handleHint}
                                        disabled={loading || sessionStatus !== 'connected'}
                                        className="w-full bg-green-600 text-white py-2 px-4 rounded hover:bg-green-700 disabled:opacity-50"
                                    >
                                        {loading ? 'Generating...' : 'Fast Hint (<200ms)'}
                                    </button>
                                    <button 
                                        onClick={handleNeuralAnalyze}
                                        disabled={loading || sessionStatus !== 'connected'}
                                        className="w-full bg-purple-600 text-white py-2 px-4 rounded hover:bg-purple-700 disabled:opacity-50"
                                    >
                                        {loading ? 'Analyzing...' : '🧠 Neural Analysis'}
                                    </button>
                                </div>
                                
                                {/* Sandbox Controls */}
                                <div className="mt-4 pt-4 border-t border-gray-200">
                                    <h4 className="text-md font-medium mb-3">🎮 Sandbox Controls</h4>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button 
                                            onClick={undoMove}
                                            disabled={loading || moveHistory.length === 0}
                                            className="bg-gray-600 text-white py-2 px-3 rounded hover:bg-gray-700 disabled:opacity-50 text-sm"
                                        >
                                            ↶ Undo
                                        </button>
                                        <button 
                                            onClick={redoMove}
                                            disabled={loading || undoStack.length === 0}
                                            className="bg-gray-600 text-white py-2 px-3 rounded hover:bg-gray-700 disabled:opacity-50 text-sm"
                                        >
                                            ↷ Redo
                                        </button>
                                    </div>
                                    <div className="mt-2">
                                        <button 
                                            onClick={clearSelection}
                                            disabled={!selectedTile}
                                            className="w-full bg-red-600 text-white py-2 px-3 rounded hover:bg-red-700 disabled:opacity-50 text-sm"
                                        >
                                            ✕ Clear Selection
                                        </button>
                                    </div>
                                    <div className="mt-2 text-xs text-gray-500">
                                        <p>💡 Drag tiles from factories to pattern lines</p>
                                        <p>🖱️ Click tiles to select, then click destination</p>
                                        <p>⌨️ Ctrl+Z: Undo, Ctrl+Y: Redo, Esc: Clear selection</p>
                                    </div>
                                </div>
                                
                                <div className="mt-3 text-xs text-gray-500">
                                    <p>✅ Exact Analysis: Alpha-beta search with depth-3</p>
                                    <p>✅ Fast Hint: MCTS with UCT algorithm</p>
                                    <p>🧠 Neural Analysis: MCTS with neural rollout policy</p>
                                    <p>✅ Database: SQLite caching enabled</p>
                                </div>
                            </div>

                            {/* FEN Display */}
                            {fenString && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-2">Position FEN</h3>
                                    <textarea 
                                        value={fenString}
                                        readOnly
                                        className="w-full h-20 p-2 text-xs font-mono bg-gray-100 rounded"
                                    />
                                    <p className="text-xs text-gray-500 mt-1">
                                        Note: Currently using "initial" position. Full FEN support coming soon.
                                    </p>
                                </div>
                            )}

                            {/* Analysis Results */}
                            {analysis && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-3">
                                        {analysis.method === 'neural_mcts' ? '🧠 Neural Analysis' : 'Exact Analysis'}
                                    </h3>
                                    <div className="space-y-2 text-sm">
                                        <div><strong>Best Move:</strong> {analysis.best_move || 'None'}</div>
                                        <div><strong>Score:</strong> {analysis.best_score?.toFixed(2) || 'N/A'}</div>
                                        <div><strong>Search Time:</strong> {analysis.search_time?.toFixed(3)}s</div>
                                        {analysis.method === 'neural_mcts' ? (
                                            <>
                                                <div><strong>Rollouts:</strong> {analysis.rollout_count || 'N/A'}</div>
                                                <div><strong>Method:</strong> Neural MCTS</div>
                                            </>
                                        ) : (
                                            <>
                                                <div><strong>Nodes:</strong> {analysis.nodes_searched?.toLocaleString() || 'N/A'}</div>
                                                <div><strong>Depth:</strong> {analysis.depth_reached || 'N/A'}</div>
                                            </>
                                        )}
                                    </div>
                                    
                                    {analysis.principal_variation && analysis.principal_variation.length > 0 && (
                                        <div className="mt-3">
                                            <strong>Principal Variation:</strong>
                                            <div className="text-xs font-mono bg-gray-100 p-2 rounded mt-1">
                                                {analysis.principal_variation.join(' → ')}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Hint Results */}
                            {hint && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-3">Fast Hint</h3>
                                    <div className="space-y-2 text-sm">
                                        <div><strong>Best Move:</strong> {hint.best_move || 'None'}</div>
                                        <div><strong>Expected Value:</strong> {hint.expected_value?.toFixed(2) || 'N/A'}</div>
                                        <div><strong>Confidence:</strong> {hint.confidence?.toFixed(2) || 'N/A'}</div>
                                        <div><strong>Search Time:</strong> {hint.search_time?.toFixed(3)}s</div>
                                        <div><strong>Rollouts:</strong> {hint.rollouts_performed || 'N/A'}</div>
                                    </div>
                                    
                                    {hint.top_moves && hint.top_moves.length > 0 && (
                                        <div className="mt-3">
                                            <strong>Top Moves:</strong>
                                            <div className="space-y-1 mt-2">
                                                {hint.top_moves.slice(0, 3).map((moveData, index) => (
                                                    <MoveOption 
                                                        key={index}
                                                        move={moveData.move}
                                                        score={moveData.score}
                                                        visits={moveData.visits}
                                                        onClick={() => setSelectedMove(moveData.move)}
                                                        isSelected={selectedMove === moveData.move}
                                                    />
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Move History */}
                            {moveHistory.length > 0 && (
                                <div className="bg-white p-4 rounded-lg shadow">
                                    <h3 className="text-lg font-medium mb-3">📜 Move History</h3>
                                    <div className="space-y-2 max-h-40 overflow-y-auto">
                                        {moveHistory.map((moveData, index) => {
                                            const annotation = getMoveAnnotation(index);
                                            return (
                                                <div key={index} className="text-sm p-2 bg-gray-50 rounded">
                                                    <div className="flex justify-between items-center">
                                                        <span className="font-medium">
                                                            Move {index + 1}
                                                            {moveData.player !== undefined && (
                                                                <span className="ml-2 px-2 py-0.5 bg-blue-200 text-blue-800 text-xs rounded">
                                                                    P{moveData.player + 1}
                                                                </span>
                                                            )}
                                                            {annotation && (
                                                                <span className="ml-2 px-2 py-0.5 bg-yellow-200 text-yellow-800 text-xs rounded">
                                                                    📝
                                                                </span>
                                                            )}
                                                        </span>
                                                        <div className="flex items-center gap-2">
                                                            {annotation && (
                                                                <button
                                                                    onClick={() => {
                                                                        alert(`Annotation for Move ${index + 1}:\n\n${annotation.annotation}`);
                                                                    }}
                                                                    className="text-xs text-yellow-600 hover:text-yellow-800"
                                                                    title="View annotation"
                                                                >
                                                                    📝
                                                                </button>
                                                            )}
                                                            <span className="text-xs text-gray-500">
                                                                {new Date(moveData.timestamp).toLocaleTimeString()}
                                                            </span>
                                                        </div>
                                                    </div>
                                                    <div className="text-xs text-gray-600 mt-1">
                                                        {moveData.description || formatMoveDescription(moveData.move)}
                                                    </div>
                                                    {annotation && (
                                                        <div className="text-xs text-yellow-700 mt-1 italic">
                                                            "{annotation.annotation}"
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                    <div className="mt-2 text-xs text-gray-500">
                                        Total moves: {moveHistory.length}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        // Render the app using React 18 createRoot
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html> 